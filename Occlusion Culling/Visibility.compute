#pragma kernel ChunkRender
#pragma kernel InitializeGrassPositions

#define THREADS_CHUNK_RENDER 64
#define THREADS_CHUNK_INIT 64

#include "noise.hlsl"

float4 viewFrustumPlanes[6];
float4 camPos;
float maxViewDistance;
float depthBias;

float4x4 vpMatrix;

struct Chunk {
    float3 position;
    int instanceStartIndex;
    int instanceCount;
};

int chunkSize;
int numChunks;

RWStructuredBuffer<Chunk> chunkBuffer;
RWStructuredBuffer<float4x4> trsBuffer;
AppendStructuredBuffer<float4x4> visibleList; 
 

Texture2D<float4> _DepthTexture;
SamplerState sampler_DepthTexture;


float planeDistance(float4 plane, float3 p) {
    return dot(plane.xyz, p) + plane.w;
} 

bool isInFrontOfPlane(float4 plane, float3 p) {
    return planeDistance(plane, p) > 0;
}

bool isChunkInFrustum(float3 chunkPosition) {
    float halfSize = chunkSize * 0.5;
    float3 corners[8] = {
        chunkPosition + float3(halfSize, halfSize, halfSize),  
        chunkPosition + float3(-halfSize, halfSize, halfSize),  
        chunkPosition + float3(halfSize, halfSize, -halfSize), 
        chunkPosition + float3(-halfSize, halfSize, -halfSize), 
        chunkPosition + float3(halfSize, -halfSize, halfSize), 
        chunkPosition + float3(-halfSize, -halfSize, halfSize),
        chunkPosition + float3(halfSize, -halfSize, -halfSize), 
        chunkPosition + float3(-halfSize, -halfSize, -halfSize) 
    };

     for (int i = 0; i < 8; i++) { 
        bool isInside = true;
        for (int j = 0; j < 6; j++) {
            if (!isInFrontOfPlane(viewFrustumPlanes[j], corners[i])) {
                isInside = false;
                break;
            }
        }
        if (isInside) {
            return true;
        }
    }

    return false;
}

bool isChunkOccluded(float3 chunkPosition) {
    float4 projectedPos = mul(vpMatrix, float4(chunkPosition, 1.0f));
    float2 projectedUV = (projectedPos.xy / projectedPos.w + 1.0f) * 0.5; 
    
    float sceneDepth = _DepthTexture.SampleLevel(sampler_DepthTexture, projectedUV, 0).r;
    float chunkDepth = (projectedPos.z / projectedPos.w);

    return chunkDepth < sceneDepth - depthBias;
}

[numthreads(THREADS_CHUNK_RENDER,1,1)]
void ChunkRender (uint3 id : SV_DispatchThreadID)
{
    Chunk chunk = chunkBuffer[id.x];

    if(chunk.instanceCount == 0) return;

    //Order is important here for  performance
    if (distance(camPos.xyz, chunk.position) > maxViewDistance ||
       !isChunkInFrustum(chunk.position) ||
        isChunkOccluded(chunk.position))
    {
        return;
    }


    int start = chunk.instanceStartIndex;
    int end = start + chunk.instanceCount;

    for (int i = start; i < end; i++) {
        float4x4 instanceTransform = trsBuffer[i];
        float3 instancePosition = mul(instanceTransform, float4(0, 0, 0, 1)).xyz;
        visibleList.Append(instanceTransform);
    }
}


int instancesPerChunk;
int terrainHeightmapResolution;

float wholeRange;
Texture2D<float4> Heightmap;
SamplerState sampler_Heightmap;
Texture2D<float4> Splatmap;
SamplerState sampler_Splatmap;

RWStructuredBuffer<int> instanceCounter;
float3 terrainSize;
float3 terrainPos;
float3 scaleMin;
float3 scaleMax;
float steepness;

float4x4 CreateTRSMatrix(float3 translation, float4 quaternionRotation, float3 scale) {
    // scale matrix
    float4x4 scaleMatrix = float4x4(
        scale.x, 0, 0, 0,
        0, scale.y, 0, 0,
        0, 0, scale.z, 0,
        0, 0, 0, 1
    );

    // rotation mat from quaternion
    float x2 = quaternionRotation.x + quaternionRotation.x;
    float y2 = quaternionRotation.y + quaternionRotation.y;
    float z2 = quaternionRotation.z + quaternionRotation.z;
    
    float xx = quaternionRotation.x * x2;
    float yy = quaternionRotation.y * y2;
    float zz = quaternionRotation.z * z2;
    float xy = quaternionRotation.x * y2;
    float xz = quaternionRotation.x * z2;
    float yz = quaternionRotation.y * z2;
    float wx = quaternionRotation.w * x2;
    float wy = quaternionRotation.w * y2;
    float wz = quaternionRotation.w * z2;

    float4x4 rotationMatrix = float4x4(
        1.0f - (yy + zz), xy - wz, xz + wy, 0.0f,
        xy + wz, 1.0f - (xx + zz), yz - wx, 0.0f,
        xz - wy, yz + wx, 1.0f - (xx + yy), 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
    );

    // translation matrix - Unity uses colum major
    float4x4 translationMatrix = float4x4(
        1, 0, 0, translation.x,
        0, 1, 0, translation.y,
        0, 0, 1, translation.z,
        0, 0, 0, 1
    );

    return mul(translationMatrix, mul(rotationMatrix, scaleMatrix));
}

float4 EulerToQuaternion(float pitch, float yaw, float roll) {
    float pitchRad = radians(pitch);
    float yawRad = radians(yaw);
    float rollRad = radians(roll);

    float cy = cos(yawRad * 0.5);
    float sy = sin(yawRad * 0.5);
    float cp = cos(pitchRad * 0.5);
    float sp = sin(pitchRad * 0.5);
    float cr = cos(rollRad * 0.5);
    float sr = sin(rollRad * 0.5);

    float4 q;
    q.x = sr * cp * cy - cr * sp * sy;
    q.y = cr * sp * cy + sr * cp * sy;
    q.z = cr * cp * sy - sr * sp * cy;
    q.w = cr * cp * cy + sr * sp * sy;

    return q;
}

float GetTerrainHeight(float2 uv)
{
    return Heightmap.SampleLevel(sampler_Heightmap, uv, 0).r;
}

float GetTerrainGrassValue(float2 uv)
{
    return Splatmap.SampleLevel(sampler_Splatmap, uv, 0).r;
}

float2 WorldToTerrainUV(float3 instancePosition, float3 terrainPosition, float terrainSize)
{
    float2 relativePosition = (instancePosition.xz - terrainPosition.xz) / terrainSize;
    return float2(relativePosition.x, relativePosition.y);
}

//https://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3
uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

//https://gist.github.com/keijiro/24f9d505fac238c9a2982c0d6911d8e3
// returns random number between 0 and 1
float Random01(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

// returns random number between -1 and 1
float Random11(uint seed)
{
    return (Random01(seed) - .5) * 2.;
}

//https://gist.github.com/keijiro/ee7bc388272548396870
float nrand(float2 uv)
{
    return frac(sin(dot(uv, float2(12.9898, 78.233))) * 43758.5453);
}

[numthreads(THREADS_CHUNK_INIT, 1, 1)]
void InitializeGrassPositions(uint3 id : SV_DispatchThreadID)
{
    Chunk chunk = chunkBuffer[id.x];
    chunk.instanceCount = 0;

    float3 chunkPos = chunk.position;
    float halfChunkSize = chunkSize / 2.0;

    //will contain cvalue of instanceCounter[0] before atomic add
    uint startIndex;
    //atomic increase of global instance counter to not interfere with other threads whe nusing the instanceCounter
    InterlockedAdd(instanceCounter[0], instancesPerChunk, startIndex);
    //starting position inside trsBuffer array. Previously set via C# using a list and its count value.
    chunk.instanceStartIndex = startIndex;
  
    uint baseSeed = Hash(id.x + (uint)(chunkPos.x * 31 + chunkPos.z * 71)); 
    uint seed = Hash(baseSeed + id.x);

    for (int i = 0; i < instancesPerChunk; i++)
    {
        float3 instancePos = chunkPos + float3(Random11(seed), 0.0, Random11(seed * 15731u)) * halfChunkSize;
        float2 uv = WorldToTerrainUV(instancePos, terrainPos, terrainSize.x);  

        if (GetTerrainGrassValue(uv) < .1) continue;

        float terrainHeight = GetTerrainHeight(uv) * terrainSize.y * 2.;
        instancePos.y += terrainHeight;

        //using another random function to create even more "randomness"
        float3 scale = lerp(scaleMin, scaleMax, nrand(uv));
        instancePos.y += scale.z / 2.;

        float angle = Random11(seed + i *  15731u) * 360.0;
        float4 quat =  EulerToQuaternion(angle, 0, 90);
        float4x4 instanceTransform = CreateTRSMatrix(instancePos, quat, scale);

        //fill buffer at correct index
        trsBuffer[startIndex + i] = instanceTransform;

        chunk.instanceCount++;

        seed += i;
    }

    //Set chunk position to average of its instances y height
    float sumY = 0.0;
    for (int j = 0; j < chunk.instanceCount; j++)
    {
        float4x4 instanceTransform = trsBuffer[startIndex + j];
        sumY += instanceTransform[1][3];
    }
    float averageY = sumY / chunk.instanceCount;
    chunk.position.y = averageY;


    chunkBuffer[id.x] = chunk;
}